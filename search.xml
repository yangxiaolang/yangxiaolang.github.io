<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Audio标签音频源无法播放的问题记录及解决</title>
    <url>/2021/06/03/audio-bug-record/</url>
    <content><![CDATA[<p>在前端获取音频文件的base64编码构造dataURL进行音频的播放，遇到了播放器不能播放音频以及在更换音频源src时仍然播放之前加载的音频源的的问题,在此做简单记录。</p>
<h2 id="audio标签的src无法使用dataURL"><a href="#audio标签的src无法使用dataURL" class="headerlink" title="audio标签的src无法使用dataURL"></a>audio标签的src无法使用dataURL</h2><p>audio的src引用的是dataUrl时,即音频文件的base64编码在前面加上媒体描述，会发生request too large的错误，原因是文本超出了url的限制，需要将音频的base64码转为文件二进制(Blob)对象，再创建一个指向该对象的URL，用src加载该URL来实现音频源的更换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bytes = <span class="variable language_">window</span>.<span class="title function_">atob</span>(voiceBase64)</span><br><span class="line"><span class="keyword">const</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(bytes.<span class="property">length</span>)</span><br><span class="line"><span class="keyword">const</span> ia = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(ab)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;bytes.<span class="property">length</span>&gt;;i++)&#123;</span><br><span class="line">    ia[i]=bytes.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Blob</span>([ab],&#123;<span class="attr">type</span>:<span class="string">&#x27;audio/mpeg&#x27;</span>&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="更换src音频源后仍然播放更换前的音频文件"><a href="#更换src音频源后仍然播放更换前的音频文件" class="headerlink" title="更换src音频源后仍然播放更换前的音频文件"></a>更换src音频源后仍然播放更换前的音频文件</h2><p>在更换音频源后，播放器未重新加载新的音频源导致新音频不能被播放，解决方案：需要调用播放器元素的load()方法重新加载音频源  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/load">HTMLMediaElement.load() - Web API 接口参考 | MDN (mozilla.org)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> player = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;audio-player&#x27;</span>)</span><br><span class="line">player.<span class="property">src</span> = newUrl</span><br><span class="line">player.<span class="title function_">load</span>()</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Cypress-端到端测试框架使用</title>
    <url>/2020/09/22/cypress-demo/</url>
    <content><![CDATA[<p>上周对开发的项目进行了一次端到端测试，暴露出了一些bug问题及不足，都是在开发时端到端测试流程所没有顾及到的，手动测试确实会有忽略及考虑不到的情况，平时也不能常常进行端到端测试。最好能够解放人力，使用自动化的方式，对项目中的一些固定关键流程定义进行自动化端到端测试。<br>正好最近学习Vue文档时对此关注了测试的部分。其中端到端测试尝试使用了推荐的Cypress框架。<br><a href="https://www.cypress.io/">Cypress官方网站</a></p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>只需要写一些简单的JS脚本作为测试用例就能对开发的前端工程进行端到端自动化测试，并能留存每一步测试的截图甚至是视频。因为cypress提供了大量的内置API，所以即使JS的基础并不强，也可以通过阅读<a href="https://docs.cypress.io/">文档</a>来编写简单的测试脚本。这里只分享一下自己的操作使用。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/08a3bb0eeffa6b5b.png" alt="测试界面截图" title="测试界面截图"><br>可以在项目中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cypress --save-dev</span><br></pre></td></tr></table></figure>
<p>在项目中引入cypress框架，但在项目的前端工程中，因为依赖的冲突，所以不能直接使用。<br>取而代之的做法是使用npm init新建了一个空项目直接将该项目作为一个测试工程，去测试服务器上的开发环境。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/98da935d7335ed64.png" alt="目录结构" title="目录结构"></p>
<ul>
<li><strong>&#x2F;cypress</strong> 存放测试工程的资源</li>
<li><strong>&#x2F;fixtures</strong> 存放模拟数据</li>
<li><strong>integration</strong> 存放测试脚本</li>
<li><strong>&#x2F;plugins</strong> 存放插件</li>
<li><strong>&#x2F;support</strong> 存放封装的自定义方法，比如在每次测试之前必然要登录到后台，可以将登录的测试流程封装起来，在每个测试脚本的before生命周期钩子中调用。</li>
</ul>
<p>cypress.json对cypress进行配置，比如测试访问的baseUrl，测试资源的存放地址，测试截图视频的存放地址，测试窗口的视窗大小等。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;baseUrl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;viewportWidth&quot;</span><span class="punctuation">:</span><span class="number">1920</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;viewportHeight&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>将一些会经常使用的脚本封装为自定义方法，以便复用。比如登录操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录操作的封装</span></span><br><span class="line"><span class="title class_">Cypress</span>.<span class="property">Commands</span>.<span class="title function_">add</span>(<span class="string">&#x27;login&#x27;</span>,<span class="function">(<span class="params">username,password</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 访问URL地址</span></span><br><span class="line">    cy.<span class="title function_">visit</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="comment">// 获取DOM节点并执行点击动作</span></span><br><span class="line">    cy.<span class="title function_">get</span>(<span class="string">&#x27;.login_span&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">    <span class="comment">// 断言当前页面为登录页</span></span><br><span class="line">    cy.<span class="title function_">url</span>().<span class="title function_">should</span>(<span class="string">&#x27;inclued&#x27;</span>,<span class="string">&#x27;loginNew&#x27;</span>)</span><br><span class="line">    cy.<span class="title function_">get</span>(<span class="string">&#x27;[placeholder=&quot;请输入登录ID&quot;]&#x27;</span>)<span class="title function_">type</span>(username)</span><br><span class="line">    cy.<span class="title function_">get</span>(<span class="string">&#x27;[placeholder=&quot;请输入密码&quot;]&#x27;</span>)<span class="title function_">type</span>(password)</span><br><span class="line">    cy.<span class="title function_">get</span>(<span class="string">&#x27;.login_button&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>经过注册之后，就可以在integration中的测试用例脚本中直接使用这些命令。<br>使用describe()描述一个测试用例集，it()定义一个测试用例，一个用例集中必须至少有一个测试用例。<br>虽然是基于js的自动化测试工具，但是几乎不需要多少js的知识，只要使用官方提供的API就能完成绝大多数测试。基本是</p>
<blockquote>
<ol>
<li>链式调用get()、contains()找到页面上符合条件的唯一DOM元素</li>
<li>使用type()和click()对获取的DOM元素进行操作</li>
<li>使用should()进行断言。</li>
</ol>
<p>  <strong>注意：</strong> 关于获取唯一的DOM元素这一点，官方推荐在需要的DOM上显式指定的data-v此类属性来帮助我们编写测试脚本时直接通过属性选择器获取，但这里还是尽量不改动原项目的代码来进行cypress的测试，使用一般的类、兄弟、父子和属性等选择器组合来获取DOM。  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;能力使用者申请能力授权&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 在全部用例执行前执行的钩子</span></span><br><span class="line">    <span class="title function_">before</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 刚刚注册自定义的方法，执行登录操作</span></span><br><span class="line">        cy.<span class="title function_">login</span>(<span class="string">&#x27;yangxiaolang&#x27;</span>,<span class="string">&#x27;yangxiaolangspasswd&#x27;</span>)</span><br><span class="line">        <span class="comment">// 登录成功进行/dashboard,断言url包含/dashboard</span></span><br><span class="line">        cy.<span class="title function_">url</span>().<span class="title function_">should</span>(<span class="string">&#x27;inclued&#x27;</span>,<span class="string">&#x27;/dashboard&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;进入申请页面&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;.el-icon-help&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;.el-menu-item&#x27;</span>).<span class="title function_">contains</span>(<span class="string">&#x27;能力授权&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">        cy.<span class="title function_">url</span>().<span class="title function_">should</span>(<span class="string">&#x27;include&#x27;</span>,<span class="string">&#x27;apply&#x27;</span>)</span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;a[href=&quot;apply&quot;]&#x27;</span>).<span class="title function_">should</span>(<span class="string">&#x27;contain&#x27;</span>,<span class="string">&#x27;授权申请&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;正确填写表单&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;[placeholder=&quot;输入系统名称&quot;&#x27;</span>).<span class="title function_">type</span>(<span class="string">&#x27;@SYSTEMNAME&#x27;</span>)</span><br><span class="line">        cy.<span class="title function_">typeDateRange</span>() <span class="comment">//也是注册的自定义方法，用于输入element的日期选择器</span></span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;.el-checkbox__label&#x27;</span>).<span class="title function_">contain</span>(<span class="string">&#x27;@ABILITYNAME&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;提交表单&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        cy.<span class="title function_">get</span>(<span class="string">&#x27;span&#x27;</span>).<span class="title function_">contains</span>(<span class="string">&#x27;提交申请&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在package.json中注册脚本命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span><span class="string">&quot;cypress open&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在控制台中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure>
<p>启动测试,会启动一个基于electron的桌面应用，选择对应的测试脚本即可进行测试<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/c868f2c694efd221.png" alt="应用页面" title="应用页面"><br><img src="https://s3.bmp.ovh/imgs/2022/04/05/12767dd84df8528e.png" alt="测试页面" title="测试页面"></p>
<p>即可对项目进行对应功能的端到端测试，在左侧可以选择查看每一步的snapshot，并且执行的测试脚本是可以热更新的。</p>
<h2 id="测试用例间持久化存储"><a href="#测试用例间持久化存储" class="headerlink" title="测试用例间持久化存储"></a>测试用例间持久化存储</h2><p>目前遇到的问题有每个测试用例间cookie和localStorage等持续化存储不共用，官方提供了不同测试用例间共用cookie的API。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/176c577453d523c7.png" alt="cookie共用方法" title="cookie共用方法"><br>localStorage的共用官方并未提供解决方案，但项目github的issue上有不少解决方案。<a href="https://github.com/cypress-io/cypress/issues/461">issue</a><br><img src="https://s3.bmp.ovh/imgs/2022/04/05/c1e1a5cddc637ea2.png" alt="localStorage共用方法" title="localStorage共用方法"></p>
<h2 id="一条命令执行自动化测试"><a href="#一条命令执行自动化测试" class="headerlink" title="一条命令执行自动化测试"></a>一条命令执行自动化测试</h2><p><a href="https://www.cypress.io/blog/2019/05/02/run-cypress-with-a-single-docker-command/">官方文档 Run Cypress with a single Docker command</a><br>使用cypress官方提供的镜像,<a href="https://github.com/cypress-io/cypress-docker-images">镜像github地址</a>,拉取镜像到本地的镜像仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull cypress/included:5.4.0</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/04/05/a0ff164f0769ec5c.png" alt="docker images" title="docker images"><br>该镜像已经安装好了执行端到端测试所需的所有依赖、浏览器和cypress,使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v $PWD:/e2e -w /e2e 8dbc </span><br></pre></td></tr></table></figure>
<p>将自己的cypress项目挂载到容器中并启动<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/4ff06141c0c2a7c9.png" alt="终端输出" title="终端输出"><br><img src="https://s3.bmp.ovh/imgs/2022/04/05/a3c1f8d422e2fd7a.png" alt="测试结果" title="测试结果"><br>测试过程的视频保存在项目的video文件夹对应的测试目录下，若有测试失败则保存截图在screenshot目录。</p>
<h2 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h2><p><a href="https://docs.cypress.io/guides/overview/why-cypress">Cypress官方文档</a></p>
<p><a href="https://www.cnblogs.com/poloyy/tag/Cypress/">国内一个比较详细的中文博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>双y轴图表两根y轴刻度不齐的处理</title>
    <url>/2020/08/18/double-yAxis-split/</url>
    <content><![CDATA[<p>双y轴的图表，由于两根y轴上各自描述了两组不同维度的数据，echarts自动计算两根y轴的刻度线时会出现显示上的间隔不均匀的情况，导致图表显示的不自然。需要手动去计算合适的y轴最大值及分割区间来解决双y轴刻度不齐的问题。<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/642bbc0b6464b006.png"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这是由于Echarts图表会自己根据数据计算合适的比例，而两根y轴的刻度间隔都是按自己维度上的数据计算得来的，这里就需要我们自己来设置要划出多少刻度，每个刻度的间隔。<br>Echarts文档中提到了splitNumber的属性,但它仅是一个建议值,实际上可能并不会生效。<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/4e05872a4ab55c5e.png" alt="splitNumber属性说明" title="splitNumber属性说明"><br><img src="https://s3.bmp.ovh/imgs/2022/04/04/02fa968444bcb679.png" alt="splitNumber并未生效" title="splitNumber并未生效"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>普遍的做法是手动设置y轴的最大最小值，并设置y轴interval，即每个刻度的间隔值。<br><img src="https://s3.bmp.ovh/imgs/2022/04/04/bbe0ab1249be93fa.png" alt="interval属性说明" title="interval属性说明"><br>需要在<strong>setOption</strong>之前根据option的数据配置计算出适合每根轴线的最大值及刻度间隔写回option</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alignYAxisScale</span>(<span class="params">option, splitNum</span>) &#123;</span><br><span class="line">    <span class="comment">//找到两根轴上的最大值向上取整</span></span><br><span class="line">    <span class="keyword">const</span> leftMax = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...option.<span class="property">series</span>[<span class="number">0</span>].<span class="property">data</span>))</span><br><span class="line">    <span class="keyword">const</span> rightMax = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...option.<span class="property">series</span>[<span class="number">1</span>].<span class="property">data</span>))</span><br><span class="line">    <span class="comment">//除去刻度数，得到每个刻度区间的值</span></span><br><span class="line">    <span class="keyword">const</span> leftInterval = leftMax / splitNum</span><br><span class="line">    <span class="keyword">const</span> rightInterval = rightMax / splitNum</span><br><span class="line">    <span class="comment">//修改图表配置</span></span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">0</span>].<span class="property">max</span> = leftMax</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">0</span>].<span class="property">interval</span> = leftInterval</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">1</span>].<span class="property">max</span> = rightMax</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">1</span>].<span class="property">interval</span> = rightInterval</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alignYAxisScale</span>(option, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/04/04/f2a364e348df6d11.png" alt="设置后的图表" title="设置后的图表"><br>可以看到图表已经实现我们想要的效果，两根y轴刻度对齐了，但是仍然存在一些问题，比如刻度值出现了小数等。此时仍然可以通过设置最大值max来调整刻度值以及线柱距最大值的距离（我一般会让线柱距离最大值之间保持一段距离）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加一个取合适的最大值的函数，个人喜好</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countPropertyMax</span>(<span class="params">max,splitNum</span>)&#123;</span><br><span class="line">    <span class="comment">// 最大值加上自己的1/10</span></span><br><span class="line">    max = max+<span class="title class_">Math</span>.<span class="title function_">ceil</span>(max/<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 递增到能被整除</span></span><br><span class="line">    <span class="keyword">while</span>(max%splitNum!==<span class="number">0</span>)&#123;</span><br><span class="line">        max++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alignYAxisScale</span>(<span class="params">option, splitNum</span>) &#123;</span><br><span class="line">    <span class="comment">//找到两根轴上的最大值向上取整,取合适的最大值</span></span><br><span class="line">    <span class="keyword">const</span> leftMax = <span class="title function_">countPropertyMax</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...option.<span class="property">series</span>[<span class="number">0</span>].<span class="property">data</span>)),splitNum)</span><br><span class="line">    <span class="keyword">const</span> rightMax = <span class="title function_">countPropertyMax</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...option.<span class="property">series</span>[<span class="number">1</span>].<span class="property">data</span>)),splitNum)</span><br><span class="line">    <span class="comment">//除去刻度数，得到每个刻度区间的值</span></span><br><span class="line">    <span class="keyword">const</span> leftInterval = leftMax / splitNum</span><br><span class="line">    <span class="keyword">const</span> rightInterval = rightMax / splitNum</span><br><span class="line">    <span class="comment">//修改图表配置</span></span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">0</span>].<span class="property">max</span> = leftMax</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">0</span>].<span class="property">interval</span> = leftInterval</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">1</span>].<span class="property">max</span> = rightMax</span><br><span class="line">    option.<span class="property">yAxis</span>[<span class="number">1</span>].<span class="property">interval</span> = rightInterval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以得到刻度线值及线柱距顶部距离比较合适的图表了<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/fe386b18462ebeca.png" alt="最终效果" title="最终效果"></p>
]]></content>
  </entry>
  <entry>
    <title>使用G6绘制知识图谱</title>
    <url>/2020/12/22/g6-kw/</url>
    <content><![CDATA[<p><strong>迁移中</strong><br>使用G6绘制一个知识图谱，知识图谱的后端主要使用思知的知识图谱API，前端使用阿里的G6绘制，echarts的力导向图的文档不太详细。简单实现思知上的知识图谱效果。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器自动将http协议访问资源提升https导致无法访问的问题</title>
    <url>/2021/07/10/http-autoupgrade-https/</url>
    <content><![CDATA[<p>浏览器最新的安全策略，初次遇到是在2021年1月份，<br>当访问的页面是以https协议被加载时，页面元素的使用不安全的http协议去加载其他图片等资源，会被浏览器自动提升成https协议，导致404等其他问题致使资源访问失败<br><strong>解决方案：</strong> 将资源以https协议的方式提供,比如Nginx代理</p>
]]></content>
  </entry>
  <entry>
    <title>数据集标注用标注组件的实现</title>
    <url>/2021/10/12/labelimage-demo/</url>
    <content><![CDATA[<p>最近接手了模型算法平台的标注平台的开发维护，之前的数据集标注组件是使用canvas绘图技术对图片进行标注绘制的，存在一些bug而且代码相当凌乱，二次开发难度相当大。正好今年6月份也在其他项目上做过一些简单的标注功能组件开发，主要使用的是SVG,当时的逻辑比较简单,但是开发效率和实际使用还是优于这边的标注组件的。<br>考虑到标注场景因为涉及大量的图形交互，并不适合使用canvas绘图，开发上比较复杂，准备基于把之前使用SVG绘图的标注组件按一些新的思路重构之后替换上去。<br><a href="https://github.com/yangxiaolang/labelimage">GitHub仓库地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>第三方标注文件导入绘制矩形位置不正确</title>
    <url>/2022/01/24/labelme-import-bug/</url>
    <content><![CDATA[<p>标注平台需要支持一些第三方标注平台比如labelme导出的标注文件的解析，绘制到我们自己平台的标注组件上。<br>但是在导入labelme标注文件之后，我们的标注组件虽然能够正常绘制，但是矩形的位置都有一定程度的偏移，多边形则都是正常的。<br>分析应该是在处理绘制矩形所需的对角端点时，未处理两端点之间的位置关系导致的。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>标注平台和labelme都是使用矩形的一组对角端点来确定唯一一个矩形的<br>labelme会判断是哪一组对角端点确定的矩形（左上-右下，左下-右上）<br>但是标注平台只能会将begin点作为矩形的左上端点，跟end点计算出width和height后绘制出矩形<br>上述区别导致了标注平台在绘制label导入标注文件的矩形时，都会向下偏移，因为把矩形左下的端点当作了矩形的左上端点<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/b705050d4d1beed6.jpg" alt="问题截图-labelme" title="问题截图-labelme"><br><img src="https://s3.bmp.ovh/imgs/2022/04/06/0400f926e41675a9.png" alt="问题截图-labelimage" title="问题截图-labelimage"></p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>考虑到文件转换过程中最好不要对原文件的原始数据做计算处理，所以在标注平台的标注组件初始化绘制标注图形时进行处理<br>通过begin点和end点的y值大小来判断end点是右上还是右下（end点必是右端点<br>计算出标注平台绘制矩形所需的左上起始点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="title class_">Math</span>.<span class="title function_">abs</span>(label.<span class="property">beginX</span> - label.<span class="property">endX</span>) *scale</span><br><span class="line"><span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">abs</span>(label.<span class="property">beginY</span> - label.<span class="property">endY</span>) *scale</span><br><span class="line"><span class="keyword">let</span> x,y</span><br><span class="line">x = (label.<span class="property">beginX</span>/<span class="variable language_">this</span>.<span class="property">bitScale</span>)*scale</span><br><span class="line">y = (label.<span class="property">beginY</span>/<span class="variable language_">this</span>.<span class="property">bitScale</span>)*scale</span><br><span class="line"><span class="keyword">if</span>(label.<span class="property">endY</span>&lt;label.<span class="property">endX</span>)&#123;</span><br><span class="line">    <span class="comment">//begin为左下端点，y减去height得到左上端点</span></span><br><span class="line">    x = (label.<span class="property">beginX</span>/<span class="variable language_">this</span>.<span class="property">bitScale</span>)*scale</span><br><span class="line">    y = ((label.<span class="property">beginY</span>-height)/<span class="variable language_">this</span>.<span class="property">bitScale</span>)*scale</span><br><span class="line">&#125;</span><br><span class="line">graph = <span class="variable language_">this</span>.<span class="property">camvas</span>.<span class="title function_">rect</span>(width/<span class="variable language_">this</span>.<span class="property">bitScale</span>,height/<span class="variable language_">this</span>.<span class="property">bitScale</span>).<span class="title function_">attr</span>(&#123;x,y&#125;)</span><br></pre></td></tr></table></figure>
<p>此处默认了begin点都是左端点，可以借此抽出通用的根据任意一组对角点获取左上起始点(这种处理仅适用于标注平台采用的的数据结构)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">[number,number]</span>&#125; <span class="variable">Point</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span> 根据矩形对角点计算矩形的绘制原点(左上端点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Point</span>&#125; <span class="variable">DiagonalPoint1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Point</span>&#125; <span class="variable">DiagonalPoint2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Point</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countRectStartPointByDiagonalPoints</span>(<span class="params">DiagonalPoint1,DiagonalPoint2</span>)&#123;</span><br><span class="line">    count [[x1,y1],[x2,y2]] = <span class="title class_">DiagonalPoint2</span>[<span class="number">0</span>] &gt;<span class="title class_">DiagonalPoint1</span>[<span class="number">0</span>]</span><br><span class="line">        ?[<span class="title class_">DiagonalPoint1</span>,<span class="title class_">DiagonalPoint2</span>]</span><br><span class="line">        :[<span class="title class_">DiagonalPoint2</span>,<span class="title class_">DiagonalPoint1</span>]</span><br><span class="line">    <span class="keyword">if</span>(x1===x2||y1===y2)&#123;</span><br><span class="line">        <span class="comment">// not DiagonalPoints</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y2&gt;y1?[x1,y1]:[x1,y2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会先计算根据两点的x值大小，取得左端点和右端点的x,y值，若两点x或y值任一相同，则入参两点为同一边上的端点，不能用作确定矩形<br>若为对角点，则再根据y值对比，返回左上的起始点坐标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="title class_">Math</span>.<span class="title function_">abs</span>(label.<span class="property">beginX</span> - label.<span class="property">endX</span>) *scale</span><br><span class="line"><span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">abs</span>(label.<span class="property">beginY</span> - label.<span class="property">endY</span>) *scale</span><br><span class="line"><span class="keyword">const</span> [x,y] = <span class="title function_">countRectStartPointByDiagonalPoints</span>(</span><br><span class="line">    [label.<span class="property">beginX</span>,label.<span class="property">beginY</span>],</span><br><span class="line">    [label.<span class="property">endX</span>,label.<span class="property">endY</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span>(x&amp;&amp;y)&#123;</span><br><span class="line">    graph = <span class="variable language_">this</span>.<span class="property">camvas</span>.<span class="title function_">rect</span>(width/<span class="variable language_">this</span>.<span class="property">bitScale</span>,height/<span class="variable language_">this</span>.<span class="property">bitScale</span>).<span class="title function_">attr</span>(&#123;x,y&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>这个改动，仅用在标注平台上的标注组件，因为其数据处理只能用在标注平台的这种描述端点的数据结构上。<br>此外，多边形不存在这个问题，因为多边形是通过完整的点集描述的闭合路径转换的 。<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/ad568692cee1c608.png" alt="最终效果" title="最终效果"></p>
]]></content>
  </entry>
  <entry>
    <title>0.0.0.0 &amp; 127.0.0.1 &amp; 本机IP的差别</title>
    <url>/2022/03/31/localhost-loopback-md/</url>
    <content><![CDATA[<p>同事在部署项目到部署环境上启动验证的时候，使用 curl 访问本机 IP 的时候 Connection refused 的了。因为 HTTP 服务启动时监听的 Host 是 127.0.0.1,导致了只有目的地址是 127.0.0.1 的请求才能被进程处理。借此也了解学习了一下 0.0.0.0 &amp; 127.0.0.1 &amp; 本机 IP 的差别。</p>
<h2 id="地址对比"><a href="#地址对比" class="headerlink" title="地址对比"></a>地址对比</h2><h3 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h3><p>代表的是本机所有 IP 地址,无论主机绑定了多少 IP 地址,只要监听了本机的 0.0.0.0 上的端口，就等于监听机器上的所有 IP 的该端口。<strong>主机所有 IP 各自所在网络的请求都可以被接收</strong>。</p>
<h3 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h3><p>是<a href="https://baike.baidu.com/item/%E5%9B%9E%E9%80%81%E5%9C%B0%E5%9D%80/8021522">环回地址（Loopback Address）</a>,代表本地主机。发往环回地址的请求，会在 <strong>IP 层</strong>短路，不再向下传递，而是立即返回。一般用于网络软件测试或进程间通信。<br>需要注意的是，如果进程监听的是本机的 127.0.0.1 上的端口，就只能接受<strong>来自本机的请求</strong>。</p>
<h3 id="本机-IP"><a href="#本机-IP" class="headerlink" title="本机 IP"></a>本机 IP</h3><p>本机 IP 是开放的 IP 地址，在网络中代表本机的 IP 地址，可通过这些 IP 地址远程访问或控制主机。进程的监听效果跟 127.0.0.1 相同，只有在 <strong>IP 所在网络内的请求</strong>才可以被接收,<strong>不包括本机</strong>。<br>即，主机有一个内网地址 IP 和一个外网地址 IP，监听哪个网络的 IP 就只能接收来自该网络内发往该 IP 的请求。</p>
<h3 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h3><p><strong>localhost 不是 IP 地址，而是一个在本地的 hosts 文件里定义好解析后 IP 的域名</strong>，一般解析为 127.0.0.1，所以一般将其作为“本地主机”。<br><img src="https://s3.bmp.ovh/imgs/2022/03/31/40d08de3414bee88.png" alt="&quot;windows解析为ipv6地址::1,linux解析为ipv4地址127.0.0.1&quot;" title="windows解析为ipv6地址::1,linux解析为ipv4地址127.0.0.1"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>127.0.0.1 和 localhost 代表本地主机，发送到该目的地址的请求不参与网络传输，一般只用于本地测试。</li>
<li>本机 IP 代表网络中的本机，本机 IP 是主机多个 IP 中的一个。</li>
<li>0.0.0.0 代表主机所有的 IP，包括内外网地址和环回地址。<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>特性</th>
<th>作为 Host 接收何种请求</th>
</tr>
</thead>
<tbody><tr>
<td>127.0.0.1</td>
<td>这是一个<a href="https://baike.baidu.com/item/%E5%9B%9E%E9%80%81%E5%9C%B0%E5%9D%80/8021522">回送地址</a>，即主机 IP 堆栈内部的 IP 地址。</td>
<td>使用回送地址发送数据，协议软件立即返回，不进行任何网络传输;</td>
<td>只接受本地请求</td>
</tr>
<tr>
<td>本机 IP</td>
<td>一种由网络地址和主机地址组成的互联网协议地址，目前存在 IPv4 和 IPv6 两种协议的 IP 地址。</td>
<td>在同一个网络地址下，主机间可相互访问。代表在该网络地址下的本机</td>
<td>只接受来自 IP 所在网络请求，不包括本机</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>在 IPv4 中，它是一个不可路由的元地址，用于指定无效、未知或不适用的目标。</td>
<td>any IPv4 address at all，所在所有网络下的本机</td>
<td>接收任意来源请求</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="程序验证"><a href="#程序验证" class="headerlink" title="程序验证"></a>程序验证</h2><p>其实这种问题很少遇到，一般网络框架都会对监听的 Host 有一个缺省值，即 0.0.0.0，除非指定了 host。下面就是通过显式声明来指定进程监听的 host 来验证。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证代码</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; query &#125; = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(query.<span class="property">name</span>);</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">`Hello <span class="subst">$&#123;query.name || <span class="string">&quot;Stranger&quot;</span>&#125;</span> , You can access me!\n`</span>);</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">listen</span>(port, host);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server running at http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br></pre></td></tr></table></figure>

<p>测试环境使用 windows 和 wsl 作为同一局域网下的两台主机,wsl 运行验证程序,同样使用 curl 进行验证。<br><img src="https://s3.bmp.ovh/imgs/2022/03/31/9ddc682431a989d8.png" alt="&quot;WSL主机IP eth0-inet:172.20.163.64&quot;" title="WSL主机IP eth0-inet:172.20.163.64"></p>
<blockquote>
<p><strong>注意：</strong>事实上，windows 和 wsl 并不适合作为测试，因为他们共享了 127.0.0.1 和 localhost,并且 windows 下的 0.0.0.0 是无效地址了。这里只是目前手头比较快速的验证方法</p>
</blockquote>
<h3 id="host-x3D-”127-0-0-1”"><a href="#host-x3D-”127-0-0-1”" class="headerlink" title="host&#x3D;”127.0.0.1”"></a>host&#x3D;”127.0.0.1”</h3><p><img src="https://s3.bmp.ovh/imgs/2022/03/31/75ccd5aa7d8e30b6.png"></p>
<h3 id="host-x3D-”172-20-163-64”-本机-IP"><a href="#host-x3D-”172-20-163-64”-本机-IP" class="headerlink" title="host&#x3D;”172.20.163.64” (本机 IP)"></a>host&#x3D;”172.20.163.64” (本机 IP)</h3><p><img src="https://s3.bmp.ovh/imgs/2022/03/31/5bf775d54a808504.png"></p>
<h3 id="host-x3D-”0-0-0-0”"><a href="#host-x3D-”0-0-0-0”" class="headerlink" title="host&#x3D;”0.0.0.0”"></a>host&#x3D;”0.0.0.0”</h3><p><img src="https://s3.bmp.ovh/imgs/2022/03/31/f13de708fb8db9b3.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://juejin.cn/post/7065520262573195294">localhost、127.0.0.1、0.0.0.0 的联系与区别</a></li>
<li><a href="https://blog.csdn.net/m0_45406092/article/details/118860649">【计算机网络】0.0.0.0 与 127.0.0.1 的区别</a></li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock.js的简单使用</title>
    <url>/2020/09/09/mock/</url>
    <content><![CDATA[<p>在前后端分离的开发中可以使用Mock.js启动MockServer拦截ajax请求并处理返回伪造的各种数据，更重要的一点是，Mock.js是无侵入的，不会破坏原本的代码结构，在后端接口开发好后就可以直接对接（接口名和数据格式需要提前约定）。<br><a href="https://github.com/nuysoft/Mock/wiki/Getting-Started">Mock.js Github地址</a></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>MockServer可以和webpack-dev-server一样，都可以当作在前端开发环境下的服务器。所以MockServer的服务我按照api-service-model的结构存放在项目的mock目录下。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/cdc928bbc406c604.png" alt="目录结构" title="目录结构"><br>分层并不是必要的，这样做只是按照一般服务端开发的习惯来编排，正巧当时写过golang的服务端，就按这种结构来划分了。同时也是为了从多个Mock接口获得的数据都是从同一份随机生成的数据计算获取而来，保证页面整体模拟数据的一致性。</p>
<ul>
<li>api层负责拦截ajax请求，解析请求携带的数据，将数据传给service层处理，将处理好的数据返回</li>
<li>service层接到api层的数据，获取model层的数据进行处理，将处理好的数据返回给api层</li>
<li>model层主要使用mock.js提供的各种随机生成数据方式，生成随机数据供service层使用。需要明确的是，这份随机数据在浏览器刷新前是固定的。</li>
</ul>
<h2 id="模拟数据构造"><a href="#模拟数据构造" class="headerlink" title="模拟数据构造"></a>模拟数据构造</h2><p>model层伪造运营数据，首先先确定一部分具有内部结构的数据，系统的能力必然是系统所拥有的能力，而能力名称与能力ID则是一一对应的关系。这里静态的部分写在一个json文件里。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/146b78e2f2e05063.png" alt="运营数据结构" title="运营数据结构"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;人证对比&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;FaceCouple&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;人脸识别&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;FaceRecognization&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>固定给出3个系统，并随机选择5-15个能力各自添加到这些系统的拥有能力下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> ability = <span class="built_in">require</span>(<span class="string">&#x27;./ability&#x27;</span>) <span class="comment">//上面的json文件，这里的require会自动解析JSON</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> systems = [<span class="string">&#x27;慧拍&#x27;</span>,<span class="string">&#x27;测温门&#x27;</span>,<span class="string">&#x27;北京门禁&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Mock</span>.<span class="property">Random</span>.<span class="title function_">extend</span>(&#123; <span class="comment">//拓展Random方法</span></span><br><span class="line">        <span class="attr">systemAbility</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// pick是内置方法，在数组内选择指定随机数量的元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">pick</span>(ability,<span class="number">5</span>,<span class="number">15</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> systemInfo=(<span class="function">()=&gt;</span>&#123; <span class="comment">// 立即执行函数，生成基础的系统信息</span></span><br><span class="line">        <span class="keyword">let</span> systemInfo=[]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;systems.<span class="property">length</span>;count++)&#123;</span><br><span class="line">                systemInfo.<span class="title function_">push</span>(mock.<span class="title function_">mock</span>(&#123;</span><br><span class="line">                        <span class="attr">systemName</span>:systems[count],</span><br><span class="line">                        <span class="comment">//使用占位符来标记使用Random方法的属性，mock会据此调用对应方法</span></span><br><span class="line">                        <span class="attr">systemAbility</span>:<span class="string">&#x27;@SYSTEMABILITY&#x27;</span></span><br><span class="line">                &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> systemInfo</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=systemInfo</span><br></pre></td></tr></table></figure>
<p>再根据模拟的系统信息systemInfo模拟运营数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> operateData=(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 生成300-500随机数量的运营数据</span></span><br><span class="line">        <span class="keyword">const</span> randomNum = mock.<span class="property">Random</span>.<span class="title function_">integer</span>(<span class="number">300</span>,<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">const</span> data = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;randomNum;count++)&#123;</span><br><span class="line">                <span class="comment">// Random拓展方法，随机选取一个系统，并随机选取系统下的一个能力</span></span><br><span class="line">                <span class="keyword">const</span> system = mock.<span class="property">Radnom</span>.<span class="title function_">system</span>()</span><br><span class="line">                <span class="keyword">const</span> ability = mock.<span class="property">Random</span>.<span class="title function_">ability</span>(system)</span><br><span class="line">                <span class="comment">// 生成一条详情数据</span></span><br><span class="line">                <span class="keyword">const</span> one = mock.<span class="title function_">mock</span>(&#123;</span><br><span class="line">                        <span class="attr">serialNumber</span>:mock.<span class="property">Random</span>.<span class="title function_">string</span>(<span class="string">&#x27;number&#x27;</span>,<span class="number">8</span>),</span><br><span class="line">                        <span class="attr">capabilityId</span>:ability.<span class="property">id</span>,</span><br><span class="line">                        <span class="attr">capabilityName</span>:ability.<span class="property">name</span>,</span><br><span class="line">                        <span class="attr">userSystem</span>:system.<span class="property">systemName</span>,</span><br><span class="line">                        <span class="comment">// 拓展的在指定日期范围内随机选择一个日期的方法，mock原生的随机日期方法较弱</span></span><br><span class="line">                        <span class="attr">callDate</span>:mock.<span class="property">Random</span>.<span class="title function_">dateInRange</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-07-07&#x27;</span>).<span class="title function_">getTime</span>(),<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()),</span><br><span class="line">                        <span class="comment">//生成0||1,生成1的概率为85/(85+15),布尔型强转为Number</span></span><br><span class="line">                        <span class="attr">status</span>:<span class="title class_">Number</span>(mock.<span class="property">Random</span>.<span class="title function_">boolean</span>(<span class="number">85</span>,<span class="number">15</span>,<span class="literal">true</span>))</span><br><span class="line">                &#125;) </span><br><span class="line">                data.<span class="title function_">push</span>(one)</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h2><p>api层使用mock.mock()方法拦截ajax请求，使用JSON.parse()解析出js对象，将数据交给service层处理，再将响应传回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mock = <span class="built_in">require</span>(<span class="string">&#x27;mock&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OperationDataService</span> = <span class="built_in">require</span>(<span class="string">&#x27;@/service/operationData/operationData&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">JsonExit</span>=(<span class="params">flag,message,data</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">                flag,</span><br><span class="line">                message,</span><br><span class="line">                data</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配路由拦截ajax请求，建议使用正则表达式</span></span><br><span class="line">mock.<span class="title function_">mock</span>(<span class="string">&#x27;/service/getall&#x27;</span>,<span class="function">(<span class="params">options</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 解析请求体</span></span><br><span class="line">        <span class="keyword">const</span> &#123;body&#125; = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(options)</span><br><span class="line">        <span class="keyword">const</span> pageNo = <span class="built_in">parseInt</span>(body.<span class="property">pageNo</span>)</span><br><span class="line">        <span class="keyword">const</span> responseData = <span class="title class_">OperateDataService</span>.<span class="title function_">getall</span>(pageNo)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">JsonExit</span>(<span class="literal">true</span>,<span class="string">&#x27;祝你好运&#x27;</span>,responseData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>service就跟普通的后端service层一样，负责业务逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> operationData = <span class="built_in">require</span>(<span class="string">&#x27;@/model/operationData/operationData&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">        <span class="attr">getall</span>:<span class="function">(<span class="params">pageNo</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">total</span>:operationData.<span class="property">length</span>.</span><br><span class="line">                        currentData=operationData.<span class="title function_">slice</span>((pageNo-<span class="number">1</span>)*<span class="number">10</span>,pageNo*<span class="number">10</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/05/2fe9079337f8d8da.png" alt="效果1" title="效果1"><br><img src="https://s3.bmp.ovh/imgs/2022/04/05/43bbf99cb9e00637.png" alt="效果2" title="效果2"><br>这样，前端能够获得渲染页面的数据，也能够帮助后端以前端的角度梳理后端数据的处理逻辑。当然从MockServer获得的数据都是处理好的不需要前端再进行处理，后端传来的数据未必不需要处理。一般来说mock数据并不需要这么多繁琐的分层步骤，这里只是为了整体页面的数据一致性才做的，不需要保证多个视图的数据计算来源一致的情况下，一般在拦截ajax请求时直接临时mock数据返回即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Nginx反向代理和负载均衡</title>
    <url>/2020/08/07/nginx-proxy-loadblance/</url>
    <content><![CDATA[<p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，它足够轻量且能承载高并发访问，关键特性就是反向代理和负载均衡。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>负载均衡很好理解，而要理解反向代理可以先聊聊我们最常接触到的正向代理。<br>我们有时会因为工作需求要访问外网查阅一些资料，但是由于某些不可抗力因素无法访问到外网的。这时我们就需要使用VPN也就是常说的梯子来达到访问外网的目的，而VPN也就是正向代理的一种。以下是正向代理的示意图。<br><img src="https://s3.bmp.ovh/imgs/2022/04/03/2d3e3e7388a502a9.png" alt="正向代理" title="正向代理"><br>可以看到，正向代理即使客户端通过代理访问目标Web服务器，代理服务器是对Web服务器隐藏了客户端的细节，即Web服务器只知道处理了从代理服务器发来的请求，但不知道发送请求的真正客户端是谁。而客户端很明确是由谁处理了自己的请求。<br>解释了正向代理，反向代理也就很好理解了。以下是反向代理的示意图。<br><img src="https://s3.bmp.ovh/imgs/2022/04/03/5262cfbf897d58bb.png" alt="反向代理" title="反向代理"><br>显而易见的，与正向代理恰恰相反，代理服务器对客户端隐藏了目标Web服务器的细节。客户端只知道将请求发到代理服务器处理，却不知道代理服务器将请求交给了哪个Web服务器去处理，甚至以为就是代理服务器处理的自己的请求。<br>由此，判断正向代理和反向代理的一个很简单的依据就是，代理服务器是对谁隐藏了谁的细节，客户端是否明确是谁真正处理了自己的请求。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>也正是因为nginx反向代理的特性，也使得它有了另一个为人称道的特性——负载均衡。它可以将处理相同请求的服务器分为一组，当需要处理请求时按照设置好的负责均衡策略将请求交给相应的服务器处理，确保服务器组的负载均衡。<br>Nginx负载均衡策略分为内置策略和拓展策略。拓展策略主要依靠用户自定义实现，而内置策略则是nginx自己提供的三种策略：</p>
<ol>
<li>轮询(或加权轮询)</li>
<li>最少连接</li>
<li>Ip_hash<br>轮询策略很好理解，假设有一个服务器组包含服务器A、服务器B和服务器C。那么处理请求的顺序就是ABCABCABC……。<br>加权轮询就是就是给服务器组中的服务器增加权重，比如服务器A：3，服务器B：2，服务器C：3。那么此时轮询策略处理请求的顺序就是AAABBCCCAAABBCCC……。可以将普通的轮询当作各服务器的权重都为1的加权轮询。<br><img src="https://s3.bmp.ovh/imgs/2022/04/03/90f2a90ab71a55a1.png" alt="轮询和加权轮询" title="轮询和加权轮询"><br>最少连接策略也很好理解，nginx服务器在转发请求时会找到正在处理请求最少的服务器将请求转发给这个服务器，保证服务器组中的各个服务器处理的请求数尽量相近达到负载均衡。<br>Ip_hash策略又称会话持久化，因为最少连接和轮询策略不能保证将相同客户端的请求转发到相同服务器上处理，这可能会导致会话session丢失，所以我们需要将某个客户端的所有请求“粘滞”在特定的服务器上。<br><img src="https://s3.bmp.ovh/imgs/2022/04/03/5262cfbf897d58bb.png" alt="IP哈希" title="IP哈希"><br>使用 IP 哈希，客户端的 IP 地址用作为哈希键，以确定应用为客户端请求选择服务器组中的哪个服务器。此方法确保了来自同一个客户端的请求始终被定向到同一台服务器，除非该服务器不可用。<br>以上是nginx内置的负载均衡策略，拓展策略则是根据用户自己的实际场景由自己实现负载均衡算法，在此不做赘述。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Html mail编写</title>
    <url>/2020/09/25/node-html-mail/</url>
    <content><![CDATA[<p>项目中的各个流程需要使用邮件通知相关人员流程的信息，当前项目仍然使用简单的字符串拼接的方式生成邮件内容，邮件样式比较简单，不够美观。可以使用html mail的方式发送样式丰富的邮件。并通过服务端渲染来替代简单的字符串拼接，让前端人员参与模板文件的开发，后端人员只需要拿到数据渲染到模板上得到最终的html发送给目标邮箱。<br><a href="http://www.ruanyifeng.com/blog/2013/06/html_email.html">阮一峰的Html mail编写指南</a>,本文档参照腾讯云文档的样式来编写Html mail,因为邮件的html显示会受到对应邮件客户端兼容性的影响，所以尽量使用table布局，只使用内联样式。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>主要使用的依赖有：</p>
<ul>
<li>nodemailer(邮件发送)</li>
<li>ejs(服务端渲染)</li>
<li>koa-bodyparse(解析request的body，接收参数)</li>
<li>koa-router(路由)</li>
<li>koa-log4(日志打印)</li>
</ul>
<p>使用nodemailer发送邮件，使用ejs模板引擎将数据渲染到模板文件上得到html字符串。服务端框架使用koa2。</p>
<!-- ![目录结构](https://s3.bmp.ovh/imgs/2022/04/05/9346e609aa4bd385.png "目录结构") -->
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app                     // 业务代码</span><br><span class="line">│   └── controller</span><br><span class="line">│       └── sendMail.js</span><br><span class="line">├── app.js                  // 入口文件</span><br><span class="line">├── config                  </span><br><span class="line">│   ├── logger.js           // 日志配置</span><br><span class="line">│   └── transporter.js      // 发件人配置</span><br><span class="line">├── logs                    // 日志</span><br><span class="line">├── middleware          </span><br><span class="line">│   ├── accessLogger.js     // 请求记录中间件</span><br><span class="line">│   └── timer.js            // 请求计时中间件</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── router                  // 路由</span><br><span class="line">│   └── index.js</span><br><span class="line">├── static</span><br><span class="line">│   └── logo.png            // 邮件logo图片</span><br><span class="line">├── utils</span><br><span class="line">│   └── logger.js</span><br><span class="line">└── views                   // 模板目录</span><br><span class="line">    ├── applyExamined.ejs</span><br><span class="line">    ├── handleApply.ejs</span><br><span class="line">    ├── releaseApply.ejs</span><br><span class="line">    ├── releaseExamined.ejs</span><br><span class="line">    └── tokenNotify.ejs</span><br></pre></td></tr></table></figure>

<h2 id="邮件模板编写"><a href="#邮件模板编写" class="headerlink" title="邮件模板编写"></a>邮件模板编写</h2><p>因为即使是相同流程的邮件，因为信息的不同，所发邮件的内容也应该不同，所以要在服务端发送邮件之前，要将数据写到模板上得到最终发送给客户端的Html字符串。跟JSP这些服务端渲染技术是一样的。<br>因为这里使用的是Node.js,所以模板引擎是ejs,发送邮件使用的是nodemailer。因为项目后端是java，所以最后落地使用的是freemaker。<br>先写好作为模板的html文件，确认好整体框架样式后，将需要模板引擎处理的部分使用模板标签标记，重命名为ejs可读的ejs文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 考虑兼容性，尽量使用table做布局 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">&quot;width:800px;margin:0 auto;background: rgb(247, 248, 250);padding-top: 8px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;padding-left:50px;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;width: 120px;height:50px;display: block;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;cid:01&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">style</span>=<span class="string">&quot;width: 700px;margin:0 auto;background-color: white;border-top: 3px solid rgb(30, 180, 255);&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;padding-left:2rem;padding-right:2rem;&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:10px&quot;</span>&gt;</span>能力授权申请已被审批<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span>&gt;</span>尊敬的AI能力开放平台用户，您好！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span>&gt;</span>您的系统<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">style</span>=<span class="string">&quot;font-weight: bold;&quot;</span>&gt;</span>&lt;%= systemName %&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>的能力授权申请已被</span><br><span class="line">                                &lt;% if(status) &#123;%&gt;</span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;font-weight: bold;&quot;</span>&gt;</span>通过<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span>&gt;</span>系统授权码为：<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold;&quot;</span>&gt;</span>&lt;%= token %&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            &lt;% &#125; %&gt;</span><br><span class="line">                            &lt;% if(!status) &#123;%&gt;</span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red;font-weight: bold;&quot;</span>&gt;</span>拒绝<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span>&gt;</span>授权能力概略如下：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">style</span>=<span class="string">&quot;width: 100%;border-color:lightgray;text-align: center;font-size: 12px;&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">style</span>=<span class="string">&quot;background: lightgray;&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>能力ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>能力名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>调用地址<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                                &lt;% data.forEach(function(item)&#123;%&gt;</span><br><span class="line">                                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&lt;%= item.capabilityId %&gt;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&lt;%= item.capabilityName %&gt;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&lt;%= item.abilityUrl %&gt;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                                &lt;% &#125;) %&gt;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- &lt;br /&gt;</span></span><br><span class="line"><span class="comment">                            &lt;p&gt;请等候平台运营者的审批。&lt;/p&gt; --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 14px;&quot;</span>&gt;</span>此致<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 14px;font-weight:bold;color: gray;&quot;</span>&gt;</span>AI产品团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 12px;color: gray;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>此为系统邮件，请勿回复。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2018 信息技术股份有限公司<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过模板引擎，我们可以在模板文件上做好标记，将数据按照标记的规则插入，并且能使用JS的语法和API进行流程控制，比如if和Array.prototype.forEach等。<br>之后在Node中将模板和对应的数据模型拼装成我们需要的Html字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> templatPath = <span class="string">&#x27;../../views/&#x27;</span> + ctx.<span class="property">params</span>.<span class="property">name</span> + <span class="string">&#x27;.ejs&#x27;</span>   <span class="comment">//根据sendMail/:name的name决定使用的模板文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; toAddress,subject,data,flag,appName,tokenContent &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>               <span class="comment">//获取request携带的数据</span></span><br><span class="line"><span class="keyword">const</span> template = ejs.<span class="title function_">compile</span>(fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, templatPath), <span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment">//读取模板文件</span></span><br><span class="line"><span class="keyword">const</span> mailData = &#123;</span><br><span class="line">    data,</span><br><span class="line">    <span class="attr">status</span>:flag,</span><br><span class="line">    <span class="attr">systemName</span>:appName,</span><br><span class="line">    <span class="attr">token</span>:tokenContent</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> html = <span class="title function_">template</span>(mailData)     <span class="comment">//将request的data渲染到模板输出html</span></span><br></pre></td></tr></table></figure>

<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p>得到了渲染好的html就能借助nodemailer将我们的邮件发出去了。需要预先配置我们的邮件传输服务器的凭证，才能通过smtp去发送邮件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transporter.js</span></span><br><span class="line"><span class="comment">// 邮件传输服务器配置</span></span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">&#x27;nodemailer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transporter = nodemailer.<span class="title function_">createTransport</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;from smtp server address&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">25</span>,</span><br><span class="line">    <span class="attr">secureConnection</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">auth</span>:&#123;</span><br><span class="line">        <span class="attr">user</span>:<span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        <span class="attr">pass</span>:<span class="string">&#x27;pass&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=transporter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendMail.js</span></span><br><span class="line"><span class="keyword">const</span> mailOption = &#123;            <span class="comment">// 邮件内容配置</span></span><br><span class="line">    <span class="attr">from</span>:<span class="string">&#x27;from address&#x27;</span>,</span><br><span class="line">    <span class="attr">to</span>:toAddress,<span class="comment">//收件人</span></span><br><span class="line">    subject,<span class="comment">//标题</span></span><br><span class="line">    html,<span class="comment">//html内容</span></span><br><span class="line">    <span class="comment">//附件,如果mail内容有插入媒体，媒体文件则来自附件，由cid指定</span></span><br><span class="line">    <span class="comment">// &lt;img style=&quot;width: 120px;height:50px;display: block;&quot; src=&quot;cid:01&quot;&gt;</span></span><br><span class="line">    <span class="attr">attachments</span>: [&#123; </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;logo.png&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../../static/logo.png&#x27;</span>),</span><br><span class="line">        <span class="attr">cid</span>: <span class="string">&#x27;01&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">transporter.<span class="title function_">sendMail</span>(mailOption, <span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        log.<span class="title function_">error</span>(<span class="string">`sendMail Failure  cost : <span class="subst">$&#123;end-start&#125;</span>ms`</span>)    <span class="comment">//失败打印日志</span></span><br><span class="line">        log.<span class="title function_">error</span>(error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">   log.<span class="title function_">info</span>(<span class="string">`sendMail Success  cost : <span class="subst">$&#123;end-start&#125;</span>ms`</span>)  <span class="comment">//成功打印日志</span></span><br><span class="line">   log.<span class="title function_">info</span>(info)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="不同邮件客户端的效果展示"><a href="#不同邮件客户端的效果展示" class="headerlink" title="不同邮件客户端的效果展示"></a>不同邮件客户端的效果展示</h2><p>验证过了公司邮箱、163邮箱和foxmail客户端都能够正常显示,但是样式最终都有所差别</p>
<h3 id="163邮箱"><a href="#163邮箱" class="headerlink" title="163邮箱"></a>163邮箱</h3><p><img src="https://s3.bmp.ovh/imgs/2022/04/06/afe09763eda492fc.png" alt="163邮箱" title="163邮箱"></p>
<h3 id="公司邮箱"><a href="#公司邮箱" class="headerlink" title="公司邮箱"></a>公司邮箱</h3><p><img src="https://s3.bmp.ovh/imgs/2022/04/06/fe195b6b169d2b28.png" alt="公司邮箱" title="公司邮箱"></p>
<h3 id="foxmail邮箱客户端"><a href="#foxmail邮箱客户端" class="headerlink" title="foxmail邮箱客户端"></a>foxmail邮箱客户端</h3><p><img src="https://s3.bmp.ovh/imgs/2022/04/06/e184e7fbbf3ebcb5.png" alt="foxmail邮箱客户端" title="foxmail邮箱客户端"></p>
]]></content>
  </entry>
  <entry>
    <title>前端页面响应速度优化实践总结</title>
    <url>/2020/12/28/pagespeed-optimize/</url>
    <content><![CDATA[<p>目前常用的前端应用架构主要为原生JS或Jquery等构筑的多页面应用（MPA)以及借助Angular&#x2F;React&#x2F;Vue等现代前端框架搭建的单页面应用(SPA)。<br>MPA的页面主要是分布在服务器上各个静态资源，即html及其引入的脚本文件和样式文件，每次跳转新的页面都要把对应页面HTML文件及其依赖下载一遍，在网速不好时，页面间的跳转会有明显的白屏时间。<br>SPA的页面只有一个，即首次访问时下载的index.html文件，其内容是有JS动态渲染到页面上的，跳转页面其实是由JS动态的将组件替换到页面上，页面跳转时不会受到网速影响，基本相当于原生的响应速度。但是所有依赖文件都会在首次访问时被下载，会使得首屏的白屏时间相当明显。<br>其他方案诸如SSR和BigPipe的架构方案暂无实践，不讨论。<br><strong>2022-04-05迁移注:</strong> 本文档主要为当时的经验总结，但实际上MPA的优化方案同样能用webpack处理，以后会再写一些文档梳理优化知识。本文档主要展示优化方案和总结思考。</p>
<h2 id="MPA的前端优化方案"><a href="#MPA的前端优化方案" class="headerlink" title="MPA的前端优化方案"></a>MPA的前端优化方案</h2><p>MPA的优化方案的重点是压缩每次访问的html文件所引入的依赖大小，并提高下载速度。一般为使用CDN服务器进行加速，压缩JS文件以及使用依赖的生产版本。</p>
<h3 id="CDN服务器加速"><a href="#CDN服务器加速" class="headerlink" title="CDN服务器加速"></a>CDN服务器加速</h3><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。<br><img src="https://img3.qq.tc/2022/04/05/CDN.png" alt="使用CDN" title="使用CDN"></p>
<h3 id="压缩JS文件"><a href="#压缩JS文件" class="headerlink" title="压缩JS文件"></a>压缩JS文件</h3><p>即减少JS文件的体积，可以通过各种工具对JS文件进行压缩，删除空格及注释等字符，压缩文件体积。<br><img src="https://img3.qq.tc/2022/04/05/65d1c5b9fdfd67bed11674f8530d0b11.png" alt="静态资源在线压缩工具" title="静态资源在线压缩工具"></p>
<h3 id="使用第三方依赖的生产版本"><a href="#使用第三方依赖的生产版本" class="headerlink" title="使用第三方依赖的生产版本"></a>使用第三方依赖的生产版本</h3><p>许多第三方依赖都提供两个版本——开发版本和生产版本。开发版本会提供完整的错误提示信息来帮助开发，生产版本则去掉这些内容并对代码进行压缩，减少了依赖体积。<br><img src="https://img3.qq.tc/2022/04/05/590c62a8d2bf68c935c55a7e1c79dda9.png" alt="开发环境和生产环境版本" title="开发环境和生产环境版本"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上方案的痛点有：</p>
<ol>
<li>依赖未必有对应版本的CDN服务，且内网环境无法使用第三方提供的CDN服务。</li>
<li>压缩代码及使用生产版本替换都需要在每次部署到生产环境时都需要手动进行处理，效率不高。且未必所有依赖都有其生产版本。</li>
</ol>
<h2 id="SPA的前端优化方案"><a href="#SPA的前端优化方案" class="headerlink" title="SPA的前端优化方案"></a>SPA的前端优化方案</h2><p>SPA的优化方案同样也有CDN加速以及压缩JS文件，且一般SPA都会由webpack等构建工具来打包生产环境，可以通过插件自动地压缩JS代码，不必再手动进行处理。<br>但是由于SPA一般通过npm来管理依赖，若SPA没有使用CDN加速的方式引入第三方依赖，是没有开发版本和生产版本之分的。<br>SPA一般只会在首屏加载时白屏时间长，所以优化的重点在于压缩首屏加载时引入文件的体积。一般的方案有： CDN加速、压缩代码、首屏加载所有第三方依赖、使用时加载组件、按需引入依赖和依赖拆分等。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>SPA同样可以使用CDN加速，但使用起来比较麻烦，且不利于开发。<br>SPA的所有依赖都是在main.js中引入的，如果使用CDN加速的话，需要去掉main.js中使用import引入的依赖，改为在html直接使用script标签引入，且需要在webpack打包配置中的externals属性中声明不需要webpack打包的依赖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webpack配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="attr">externals</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;vue&#x27;</span>:<span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue-router&#x27;</span>:<span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element-ui&#x27;</span>:<span class="string">&#x27;ELEMENT&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vcharts&#x27;</span>:<span class="string">&#x27;vcharts&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左值是webpack不打包的依赖，右值是应用中使用这些依赖的变量名，webpack是的打包构建是通过静态分析的，如果不配置右值，会将使用的变量名打包成其他名称，造成运行时获取的依赖无法正常使用。</p>
<p>同样的由于依赖是运行时获取的，eslint等静态代码检查工具在开发时是会报错的。</p>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>由于SPA一般都有webpack这样的打包工具，这些工具的默认配置会在打包生产环境时会自动进行代码压缩。同样地也能使用插件配置来定制化压缩。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用UglifyJsPlugin删除console和debugger语句</span></span><br><span class="line"><span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">compress</span>:&#123;</span><br><span class="line">        <span class="attr">warnings</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">drop_debugger</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">drop_console</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用时加载组件"><a href="#使用时加载组件" class="headerlink" title="使用时加载组件"></a>使用时加载组件</h3><p>SPA首屏响应时间较长的原因是在首屏加载时就载入了所有依赖文件，其中包括所有的页面组件文件。<br>但是由于许多页面并不会在一开始就展示出来，所以没有在首屏加载时就下载的必要，所以页面的组件文件要在路由中进行按需加载。即仅在该页面被首次访问时，才下载该组件文件，此后访问即可直接使用内存中的组件文件。<br><img src="https://img3.qq.tc/2022/04/05/8b7c2b7fdc303ccccd1155a6ce2f73c7.png" alt="在路由中动态引入组件" title="在路由中动态引入组件"></p>
<h3 id="按需引入第三方依赖"><a href="#按需引入第三方依赖" class="headerlink" title="按需引入第三方依赖"></a>按需引入第三方依赖</h3><p>一般第三方依赖的文档都会写明有两种引入方式——全部引入和按需引入。一般诸如图表库和组件库，我们只使用其中的一部分图表或组件，就没必要全部引入，全部引入虽然方便开发但是会增加引入的体积。</p>
<p>一些组件库如vuetify本身提供摇树（treeshaking）功能，会自动移除 JavaScript 上下文中的未引用代码(dead-code)，所以无需按需引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部引入element-ui</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按需引入element-ui,babel配置不粘贴了https://element.eleme.cn/#/zh-CN/component/quickstart</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="title class_">Button</span>.<span class="property">name</span>, <span class="title class_">Button</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="title class_">Select</span>.<span class="property">name</span>, <span class="title class_">Select</span>);</span><br><span class="line"><span class="comment">/* 或写为</span></span><br><span class="line"><span class="comment"> * Vue.use(Button)</span></span><br><span class="line"><span class="comment"> * Vue.use(Select)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="依赖拆分"><a href="#依赖拆分" class="headerlink" title="依赖拆分"></a>依赖拆分</h3><p>一般webpack打包时会将业务代码打到app.js，第三方依赖全部打包到vendor.js文件，如文章开头所说，优化响应速度地要点是压缩单个文件的体积。</p>
<p>app.js和vendor.js在浏览器中是并行加载的，如果第三方依赖较多，就会导致vendor.js文件体积过大，不利于响应速度的提升，所以我们需要将一些依赖从vendor文件中提取出来跟他们并行下载。</p>
<p>使用webpack的CommonsChunkPlugin(webpack4后被弃用）或SplitChunksPlugin（webpack4以上）进行代码块的提取。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webpack提取代码块配置</span></span><br><span class="line"><span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">    <span class="attr">chunks</span>:[<span class="string">&#x27;vendor&#x27;</span>],</span><br><span class="line">    <span class="title function_">minChunks</span>(<span class="params">modules</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="variable language_">module</span>.<span class="property">resource</span> &amp;&amp;</span><br><span class="line">            <span class="regexp">/echarts/</span>.<span class="title function_">test</span>(<span class="variable language_">module</span>.<span class="property">resource</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;v-charts&#x27;</span>,</span><br><span class="line">    <span class="attr">chunks</span>:[<span class="string">&#x27;vendor&#x27;</span>],</span><br><span class="line">    <span class="title function_">minChunks</span>(<span class="params">modules</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="variable language_">module</span>.<span class="property">resource</span> &amp;&amp;</span><br><span class="line">            <span class="regexp">/v-charts/</span>.<span class="title function_">test</span>(<span class="variable language_">module</span>.<span class="property">resource</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这些依赖文件在打包后是在index.html文件中通过script标签来引入的，所以要注意依赖引入的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整依赖引入顺序配置</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">filename</span>:config.<span class="property">build</span>.<span class="property">index</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">    <span class="attr">favicon</span>:<span class="title function_">resolve</span>(<span class="string">&#x27;favicon.ico&#x27;</span>),</span><br><span class="line">    <span class="attr">inject</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minify</span>:&#123;</span><br><span class="line">        <span class="attr">removeComments</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">collapseWhitespace</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeAttributeQuotes</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 手动排序代码块</span></span><br><span class="line">    <span class="attr">chunksSortMode</span>:<span class="string">&#x27;manual&#x27;</span>,</span><br><span class="line">    <span class="attr">chunks</span>:[<span class="string">&#x27;manifest&#x27;</span>,<span class="string">&#x27;vendor&#x27;</span>,<span class="string">&#x27;vue&#x27;</span>,<span class="string">&#x27;vue-router&#x27;</span>,<span class="string">&#x27;element-ui&#x27;</span>,<span class="string">&#x27;echarts&#x27;</span>,<span class="string">&#x27;v-charts&#x27;</span>,<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">    <span class="attr">chunks</span>:[<span class="string">&#x27;vendor&#x27;</span>,<span class="string">&#x27;vue&#x27;</span>,<span class="string">&#x27;vue-router&#x27;</span>,<span class="string">&#x27;element-ui&#x27;</span>,<span class="string">&#x27;echarts&#x27;</span>,<span class="string">&#x27;v-charts&#x27;</span>,<span class="string">&#x27;app&#x27;</span>],</span><br><span class="line">    <span class="attr">minChunks</span>:<span class="title class_">Infinity</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="服务器端优化前端响应速度方案"><a href="#服务器端优化前端响应速度方案" class="headerlink" title="服务器端优化前端响应速度方案"></a>服务器端优化前端响应速度方案</h2><p>大部分浏览器现在都支持解压gzip压缩文件，所以可以将请求的文件压缩成gzip压缩文件进行传输，可以有效减少传输文件的体积。此方法需要服务器的支持，在nginx服务器中配置如下。<br><img src="https://img3.qq.tc/2022/04/05/nginxgzip.png" alt="Nginx开启gzip压缩" title="Nginx开启gzip压缩"><br>服务器会自行将访问的js等静态资源文件实时压缩成gzip文件传输给客户端，显然此举会增加服务器的压力，所以前端可以在webpack打包时除了js文件外另外生成一份同名的gzip文件，可以由服务器直接将该gzip文件传输给客户端，减轻服务器压力。</p>
<p>使用compression-webpack-plugin插件增加如下配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webpack生成gzip文件配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="attr">productionGzip</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">productionGzipExtensions</span>:[<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>页面展示PDF文档的方案</title>
    <url>/2021/03/11/pdf-viewer/</url>
    <content><![CDATA[<p>在自己负责的项目接入公司级平台的时候，要求项目页面上提供说明文档，而且不能是类似VuePress那样的静态博客网站式的文档，正好项目本身有PDF版本的说明文档，尝试一下实现PDF阅览器展示PDF说明文档实现这个要求。</p>
<h2 id="iframe使用built-in-pdf-viewer"><a href="#iframe使用built-in-pdf-viewer" class="headerlink" title="iframe使用built-in pdf viewer"></a>iframe使用built-in pdf viewer</h2><p>目前大多数的主流浏览器都支持PDF文档的浏览，所以如果想要在页面中展示PDF文件，一个比较简单的方案就是使用iframe嵌套一个browsing context。它能够将另一个打开了PDF阅览器的页面嵌入到当前页面中。</p>
<ul>
<li>优点是浏览器本身的PDF阅览器的功能丰富，展示效果好，不需要额外开发。</li>
<li>缺点则是无法拓展阅览器功能，且受浏览器兼容性限制<a href="https://caniuse.com/?search=pdf">Built-in PDF viewer兼容性</a>。</li>
</ul>
<p><img src="https://img3.qq.tc/2022/04/06/built-in-pdf-viewer.png" alt="built-in-pdf-viewer兼容性" title="built-in-pdf-viewer兼容性"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pdf<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;pdf&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px;height:400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">convertDataURIToBinary</span>(<span class="params">base64data</span>)&#123;<span class="comment">//编码转换</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> raw = <span class="variable language_">window</span>.<span class="title function_">atob</span>(base64data)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> rawLength = raw.<span class="property">length</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(rawLength))</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;rawLength;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">                array[i] = raw.<span class="title function_">charCodeAt</span>(i)&amp;<span class="number">0xff</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> array</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">base2Blob</span>(<span class="params">base64data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> u8arr = <span class="title function_">convertDataURIToBinary</span>(base64data)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([u8arr],&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>:<span class="string">&quot;application/pdf&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> blob = <span class="title function_">base2Blob</span>(base64)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#pdf&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            el.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>,<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob))</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img3.qq.tc/2022/04/06/iframe.png" alt="iframe展示PDF文档" title="iframe展示PDF文档"></p>
<h2 id="Mozila-pdfjs"><a href="#Mozila-pdfjs" class="headerlink" title="Mozila pdfjs"></a>Mozila pdfjs</h2><p>另一个方案则是使用Mozila开源的pdf.js 来实现pdf在前端页面上的阅览功能 <a href="https://github.com/mozilla/pdf.js">GitHub - mozilla&#x2F;pdf.js: PDF Reader in JavaScript</a>,它可以读取远程的PDF文件，并将它的相应页码绘制在canvas上，透过它，我们可以自定义开发一些浏览器内置的PDF阅览器不支持的功能.</p>
<h3 id="使用npm-安装pdfjs的依赖，在入口文件中引入"><a href="#使用npm-安装pdfjs的依赖，在入口文件中引入" class="headerlink" title="使用npm 安装pdfjs的依赖，在入口文件中引入"></a>使用npm 安装pdfjs的依赖，在入口文件中引入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pdfjs = <span class="built_in">require</span>(<span class="string">&#x27;pdfjs-dist/es5/build/pdf&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> pdfjsWorker = <span class="built_in">require</span>(<span class="string">&#x27;pdfjs-dist/es5/build/pdf.worker.entry&#x27;</span>)</span><br><span class="line">pdfjs.<span class="property">GlobalWorkerOptions</span>.<span class="property">workerSrc</span> = pdfjsWorker</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> pdfjs使用了js语法的新特性，直接引入可能会报错，解决方案见<a href="https://github.com/mozilla/pdf.js/issues/13190#issuecomment-814701619">node packge pdfjs-dist@2.6.347 syntax error · Issue #13190 · mozilla/pdf.js · GitHub</a></p>
<h3 id="新建PDFViewer组件"><a href="#新建PDFViewer组件" class="headerlink" title="新建PDFViewer组件"></a>新建PDFViewer组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-infinite-scroll</span>=<span class="string">&quot;loadPage&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:infinite-scroll-distance</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;content&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用canvas渲染pdf页面内容，canvas的父容器使用element的无限加载做加载下一页<br>组件挂载完成后获取该父容器的Element对象保存，loadPage方法主要是将pdf的内容渲染到canvas节点再添加到父容器的子结点上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">contentEl</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">loadPage</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;page&#x27;</span> + <span class="variable language_">this</span>.<span class="property">pageCount</span>);</span><br><span class="line">            div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;page&#x27;</span>);</span><br><span class="line">            div.<span class="property">style</span>.<span class="property">marginTop</span> = <span class="string">&#x27;30px&#x27;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">contentEl</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">            <span class="variable language_">this</span>.$nextTick(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="title function_">renderPage</span>(div, <span class="variable language_">this</span>.<span class="property">pageCount</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">pageCount</span>++;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 渲染对应页面</span></span><br><span class="line">        <span class="attr">renderPage</span>: <span class="keyword">function</span>(<span class="params">div, pageNum</span>) &#123;</span><br><span class="line">             <span class="comment">// 异步获取pdf对象对应页的内容渲染到canvas节点上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">doc</span></span><br><span class="line">                .<span class="title function_">getPage</span>(pageNum)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">                    div.<span class="title function_">appendChild</span>(canvas);</span><br><span class="line">                    <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">                    <span class="keyword">const</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> bsr =</span><br><span class="line">                      ctx.<span class="property">webkitBackingStorePixelRatio</span> ||</span><br><span class="line">                      ctx.<span class="property">mozBackingStorePixelRatio</span> ||</span><br><span class="line">                      ctx.<span class="property">msBackingStorePixelRatio</span> ||</span><br><span class="line">                      ctx.<span class="property">oBackingStorePixelRatio</span> ||</span><br><span class="line">                      ctx.<span class="property">backingStorePixelRatio</span> ||</span><br><span class="line">                      <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> ratio = dpr / bsr;</span><br><span class="line">                    <span class="keyword">const</span> viewport = content.<span class="title function_">getViewport</span>(&#123; <span class="attr">scale</span>: <span class="number">1.2</span> &#125;);</span><br><span class="line">                    canvas.<span class="property">width</span> = viewport.<span class="property">width</span> * ratio;</span><br><span class="line">                    canvas.<span class="property">height</span> = viewport.<span class="property">height</span> * ratio;</span><br><span class="line">                    canvas.<span class="property">style</span>.<span class="property">width</span> = viewport.<span class="property">width</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                    canvas.<span class="property">style</span>.<span class="property">height</span> = viewport.<span class="property">height</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pageHeight</span> &lt; div.<span class="property">clientHeight</span>) &#123;</span><br><span class="line">                      <span class="variable language_">this</span>.<span class="property">pageHeight</span> = div.<span class="property">clientHeight</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.pageHeight&#125;</span>px`</span>;</span><br><span class="line">                    ctx.<span class="title function_">setTransform</span>(ratio, <span class="number">0</span>, <span class="number">0</span>, ratio, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">const</span> renderContext = &#123;</span><br><span class="line">                      <span class="attr">canvasContext</span>: ctx,</span><br><span class="line">                      viewport</span><br><span class="line">                    &#125;;</span><br><span class="line">                    content.<span class="title function_">render</span>(renderContext);</span><br><span class="line">                    <span class="title function_">resolve</span>();</span><br><span class="line">                &#125;)</span><br><span class="line">                .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>pdfjs获取的pdf文档，即getDocument方法的入参是pdf文件的url，所以需要webpack遇到引入pdf文件时将其作为静态资源处理，增加url-loader对pdf文件的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.pdf$/</span>,</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">limit</span>:<span class="number">10000</span>,</span><br><span class="line">      <span class="attr">name</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;pdf/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>初步效果，翻页缩放等控件还需要手动开发<br><img src="https://img3.qq.tc/2022/04/06/pdfjs.png" alt="pdfjs绘制的PDF文档" title="pdfjs绘制的PDF文档"></p>
]]></content>
  </entry>
  <entry>
    <title>远程调试Android手机edge浏览器方法</title>
    <url>/2022/02/15/remote-mobile-debug/</url>
    <content><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/remote-debugging/">远程调试 Android 设备 - Microsoft Edge Development | Microsoft Docs</a></p>
]]></content>
  </entry>
  <entry>
    <title>Safari10兼容性处理及Babel升级</title>
    <url>/2022/02/09/safari-babel-upgrade/</url>
    <content><![CDATA[<p>不知道哪个地方的项目经理，售前阶段准备熟悉下我们平台，结果白屏了，老大发了我一个问题截图，报错信息是’未预期的符号“…”,预期一个属性名’,似乎是浏览器不支持展开运算符，导致的项目不能正常加载，问下了使用的浏览器，safari10 。emmm…,苹果的升级策略看样子挺保守的(-_-) 。<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/ff26f7e3b731bfdf.png" alt="问题截图" title="问题截图"></p>
<h2 id="兼容性问题确认"><a href="#兼容性问题确认" class="headerlink" title="兼容性问题确认"></a>兼容性问题确认</h2><p>报错信息：<strong>未预期的符号”…”,预期一个属性名</strong><br>先定位下报错截图处的代码，应该不是用在函数执行时的剩余运算符”…” <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">剩余参数 - JavaScript | MDN (mozilla.org)</a> 。<br> 这里的 “…” 是ES2015增加的展开语法，用来展开数组等结构，展开对象是ES2018的标准，此处应该是浏览器支持的标准不支持此语法用于对象（expect a property name） <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals">展开语法 - JavaScript | MDN (mozilla.org)</a><br>查询支持 …语法 的浏览器版本<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/6ec732159a8a1a0c.jpg" alt="Spread in object literals兼容性" title="Spread in object literals兼容性"><br>可以看到Safari11以下版本的浏览器是不支持的<a href="https://caniuse.com/?search=Spread%20in%20object%20literals">Spread in object literals</a><br>但是，在使用webpack打包时是使用babel编译过源代码的，目标代码应该被babel降级到了es5标准，制品中应该不存在展开语法,在制品中查找到在对象结构中使用了展开语法的语句<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/0b6982a22f071a2e.jpg" alt="问题代码" title="问题代码"><br>问题语句上下文使用了**isMatrixLike()**方法，业务代码中没有这个方法，定位到使用的绘图用svgjs依赖中存在此方法。也就是babel未处理node_modules里的依赖（一般也不用处理，因为npm仓库上的一般也是提供者自己处理过的<br>在AI能开的模板工程中，babel使用的是v6版本，会自动忽略node_modules目录，需要升级到v7才能通过配置文件babel.config.js 来指定处理目录<br><img src="https://s3.bmp.ovh/imgs/2022/04/06/10d5ded8dba2b7d0.jpg" alt="Babel升级文档" title="Babel升级文档"></p>
<h2 id="Babel升级"><a href="#Babel升级" class="headerlink" title="Babel升级"></a>Babel升级</h2><h3 id="Babel简介"><a href="#Babel简介" class="headerlink" title="Babel简介"></a>Babel简介</h3><p>Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：</p>
<ul>
<li>语法转换</li>
<li>通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）</li>
<li>源码转换（codemods）</li>
</ul>
<h3 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h3><ol>
<li>删除package.json依赖列表中babel相关依赖，删除node_modules目录</li>
<li>重新npm install依赖</li>
<li>根据手册安装babel核心组件  使用指南 · Babel 中文网 (babeljs.cn)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure></li>
<li>根据原有babel6.x使用的插件安装新的babel7.x对应的插件及其依赖（命名规则也改变了<ul>
<li>@babel&#x2F;eslint-parse  替代 babel-eslint 做静态代码分析</li>
<li>@babel&#x2F;plugin-transform-runtime</li>
<li>@babel&#x2F;plugin-syntax-dynamic-inmport</li>
<li>@babel&#x2F;runtime-corejs3</li>
<li>corejs@3</li>
<li>babel-loader@8</li>
</ul>
</li>
<li>修改配置文件 .babelrc &#x3D;&gt; babel.config.js , 内容修改<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&#x27;entry&#x27;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">targets</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;browsers&#x27;</span>: [<span class="string">&#x27;&gt; 1%&#x27;</span>, <span class="string">&#x27;last 4 versions&#x27;</span>, <span class="string">&#x27;not ie &lt;= 8&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 内置在preset-env中，不需要单独安装,开启loose模式,提高兼容性</span></span><br><span class="line">    [<span class="string">&#x27;@babel/plugin-transform-spread&#x27;</span>, &#123; <span class="attr">useBuiltIns</span>: <span class="literal">true</span>, <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/plugin-proposal-object-rest-spread&#x27;</span>,</span><br><span class="line">      &#123; <span class="attr">useBuiltIns</span>: <span class="literal">true</span>, <span class="attr">loose</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">development</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-syntax-dynamic-import&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>babel-polyfill已被弃用，修改main.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;babel-polyfill&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>替换eslint配置使用的解析为@babel&#x2F;eslint-parser<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">parserOptions</span>:&#123;</span><br><span class="line">        <span class="comment">// parser:&quot;babel-eslint&quot;</span></span><br><span class="line">        <span class="attr">parser</span>:<span class="string">&quot;@babel/eslint-parser&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>webpack的打包基础配置修改，babel-loader指定处理svgjs目录<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">loader</span>:<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>,</span><br><span class="line">    <span class="attr">include</span>:[</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;node_modules/@svgdotjs/scgjs&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2>因为我没有Mac设备，所以兼容性测试用了下一些云测试平台，<a href="https://app.lambdatest.com/">lambdatest平台</a><br><img src="https://s3.bmp.ovh/imgs/2022/04/06/07a878edb6d016bc.jpg" alt="处理前" title="处理前"><br><img src="https://s3.bmp.ovh/imgs/2022/04/06/f220d925addf32a3.jpg" alt="处理后" title="处理后"></li>
</ol>
<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>说起来这个兼容性问题我一直耿耿于怀，因为当初用svgdotjs开发标注组件的时候，还特意看了下兼容性，记得文档里提到了safari3.2以上的都支持，这作者没测试充分呀。<br>于是憋了半天用英文写好了issue，说明了问题和我的解决方案，检查了好几遍英文有没有问题才发出去，结果发完了才发现</p>
<p><strong>他文档里说的是SVG的兼容性</strong></p>
<p>尴尬的我赶紧关了issue，作者应该还没看见吧（-_-）</p>
]]></content>
  </entry>
  <entry>
    <title>单点登录各方案的原理及整理</title>
    <url>/2021/09/10/sso-packup/</url>
    <content><![CDATA[<p>担任前端开发到现在，负责的项目也根据现场落地情况对接过一些平台的单点登录框架，虽然都是单点登录，前面叫的名不一样，但多少都有一些相同点，原理也基本相同。整理此文档记录遇到的单点登录方案原理及流程，也是为了方便围绕单点登录的工作机制来制定安全的实现方案。目前接触过的主要是:<br><strong>OAuth2框架:</strong> 通过共享认证中心，通过认证中心的cookie来实现第二次免登录。<br><strong>同域名Cookie共享:</strong> 同一域名下的应用共享顶级的cookie，直接根据cookie解析用户信息。</p>
<h2 id="单点登录本质"><a href="#单点登录本质" class="headerlink" title="单点登录本质"></a>单点登录本质</h2><p>单点登录本质是通过存储在客户端的凭证信息（多为cookie）来实现同一单点登录体系下各应用系统的用户信息共享。<br>共享的方式有：</p>
<ol>
<li>通过共享认证中心，通过认证中心的cookie来实现第二次免登录。</li>
<li>同一域名下的应用共享顶级的cookie，直接根据cookie解析用户信息。</li>
</ol>
<h2 id="同一域名共享Cookie"><a href="#同一域名共享Cookie" class="headerlink" title="同一域名共享Cookie"></a>同一域名共享Cookie</h2><p>通过将同一体系下的应用系统都借助Nginx服务器的地址代理转发，共享同一个域下的cookie来实现用户信息的共享。<br>在此体系上部署的应用都是通过同一个顶级地址访问的，所以会共享此地址下的cookie，即可通过共享cookie内容处理解析用户信息实现单点登录。<br><img src="https://img3.qq.tc/2022/04/05/cookie.png" alt="同域名共享Cookie单点登录流程" title="同域名共享Cookie单点登录流程"><br>因为在同一个域下，所以该体系下各应用系统的服务端都可以拿到该域的cookie，即应用系统之间服务端间的通信只需要将前端请求中的cookie构造在跨服务端的请求头中即可实现，不需要特殊实现。</p>
<h2 id="OAuth2框架"><a href="#OAuth2框架" class="headerlink" title="OAuth2框架"></a>OAuth2框架</h2><p>使用OAuth2框架实现的这种单点登录一般需要一个统一的认证中心来鉴权，访问应用系统需要鉴权时，客户端必然会跳转至认证中心鉴权，首次登录时需要输入用户凭证，第二次认证中心会根据cookie判断是否已登录直接跳回对应应用系统。需要注意：认证中心和各应用系统可以不在同一域内，即cookie可能无法共享<br>也即是说在访问应用系统的时候，客户端是经过认证中心页面鉴权之后才重定向回到的应用系统页面。他们的cookie是不同域的，应用系统的服务端无法在请求中拿到其他域的cookie。<br><img src="https://img3.qq.tc/2022/04/05/OAuth2.png" alt="OAuth2框架单点登录流程" title="OAuth2框架单点登录流程"><br>所以此类单点登录的认证都必须在客户端页面上访问认证中心来做鉴权，对于单纯的服务端间通信很不友好，不能像统一运维OP单点那样服务端构造请求的时候将客户端请求头中的cookie装载进去即可，因为服务端是拿不到认证中心域的cookie的。</p>
]]></content>
  </entry>
  <entry>
    <title>流媒体服务器镜像制作及视频ffmpeg循环推流</title>
    <url>/2021/07/01/stream-meida-server/</url>
    <content><![CDATA[<p>项目在某地的落地需要引入对摄像头等设备的RTSP视频流数据的处理，目前测试用的摄像头无法支持稳定的多客户端连接且处于无法访问的状态。为了便于测试和日后的部署安装流媒体服务器，需要制作一个流媒体服务器的Docker镜像以及用一个普通视频循环推流模拟一个未预期视频流长度的的视频流。</p>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><ol>
<li>考虑搭建nginx流媒体服务器，接收视频流存储为TS切片文件，处理来自客户端的访问，这样多客户端访问的就是流媒体服务器上的视频流(TS切片文件)，而非直连硬件设备。</li>
<li>制作Docker镜像以方便部署流媒体服务器容器到目标主机，一次编译安装流媒体服务器即可到处部署。</li>
<li>使用ffmpeg编解码工具将摄像头的rtsp视频流或循环读取视频转为rtmp视频流推送到流媒体服务器。</li>
</ol>
<h2 id="方案实施"><a href="#方案实施" class="headerlink" title="方案实施"></a>方案实施</h2><ol>
<li>下载<a href="http://nginx.org/en/download.html">Nginx源码</a>和<a href="https://github.com/arut/nginx-rtmp-module">nginx-rtmp-module</a>源码到相同目录</li>
<li>编写nginx配置<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4000</span>;</span><br><span class="line">        <span class="attribute">application</span> cctvf &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">hls_path</span> /usr/local/nginx/html/cctvf;</span><br><span class="line">            <span class="attribute">hls_fragment</span> <span class="number">5s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写Dockerfile<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于最小的Linux系统镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> rtmp-server</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx-1.14.0 rtmp-server/nginx-1.14.0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx-rtmp-module rtmp-server/nginx-rtmp-module</span></span><br><span class="line"><span class="comment"># 设置软件包镜像源并更新</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main/&quot;</span> &gt; /etc/apk/repositories \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; apk update \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; apk upgrade \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 安装nginx的编译环境</span></span></span><br><span class="line">&amp;&amp; apk <span class="keyword">add</span><span class="language-bash"> gcc g++ make libffi-dev openssl-dev \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">cd</span> /rtmp-server/nginx-1.14.0 \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 配置编译安装nginx</span></span></span><br><span class="line">&amp;&amp; sh configure --prefix=/usr/local/nginx --<span class="keyword">add</span><span class="language-bash">-module=../nginx-rtmp-module     --with-http_ssl_module --without-http_rewrite_module \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; make \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; make install \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 卸载编译环境</span></span></span><br><span class="line">&amp;&amp; apk del gcc g++ make libffi-dev openssl-dev \</span><br><span class="line">&amp;&amp; mkdir /usr/local/nginx/html/cctvf</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/nginx/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>执行Docker命令制作镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t rtmp-server .</span><br></pre></td></tr></table></figure></li>
<li>启动容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p$port:$port rtmp-server</span><br></pre></td></tr></table></figure></li>
<li>使用ffmepg循环读取视频文件并推流。<a href="https://www.jianshu.com/p/2b609afb9800">ffmpeg安装教程</a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -re  -stream_loop -1 -i $video_topath -vcodec copy -acodec copy -f flv -y rtmp://$ip:$port/$rmtp_path</span><br></pre></td></tr></table></figure></li>
<li>使用OBS或VLC等可读取网络串流的媒体播放器播放<br><img src="https://img3.qq.tc/2022/04/05/ffmpeg.png" alt="ffmpeg推流" title="ffmpeg推流"><br><img src="https://img3.qq.tc/2022/04/05/OBS.png" alt="通过OBS播放视频流" title="通过OBS播放视频流"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>待迁移的技术博客</title>
    <url>/2022/04/05/todo-list/</url>
    <content><![CDATA[<p><a href="http://eip.teamshub.com/t/5070582">使用G6绘制知识图谱并进行查找、除枝的交互实现</a><br><a href="http://eip.teamshub.com/t/5531875">活体检测webrtc调用摄像头设备</a><br><a href="http://eip.teamshub.com/t/5547984">我的数据集标注组件</a><br><a href="http://eip.teamshub.com/t/5632662">标注组件旋转的问题及实现</a></p>
]]></content>
  </entry>
  <entry>
    <title>Webpack升级导致内存泄露的定位排查</title>
    <url>/2021/01/27/webpack-upgrade-bug/</url>
    <content><![CDATA[<p>给开发项目做webpack v3升级到webpack v4的之后，在build的时候出现了内存泄漏的问题，折腾了好几天终于定位解决了，虽然这个问题估计几乎不会有人能遇到了，但还是记录一下，主要是定位的思路。<br>是内存不足还是内存泄漏?内存泄漏<br>是运行时还是编译时的内存泄漏?编译时<br>使用什么方法排查编译时的内存泄漏发生在打包什么模块时?二分法</p>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>开发的项目使用的是之前的前端在github找的一个vue后台管理模板，按要求更换到公司的vue后台管理模板工程，涉及到webpack v3到webpack v4的升级，在升级完成之后，dev模式启动未出现问题，但是build的时候却出现了内存泄露的问题。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/e36cefe5c968e771.png" alt="内存泄漏问题截图" title="内存泄漏问题截图"></p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>根据搜索build时JavaScript heap out of memory,得到一般的解决方案为增加node进程可用的最大内存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --max_old_space_size=4096 build/build.js</span><br></pre></td></tr></table></figure>
<p>增加node在打包时的可用最大内存为4G，但同样会出现上述的JavaScript heap out of memory，猜测有内存泄漏的问题。<br>观察windows的任务管理器，打包生产版本时内存使用率达到了1G以上且仍在增长，正常情况应稳定为400-600MB。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/f3cb5c76024f899c.png" alt="任务管理器" title="任务管理器"><br>由于dev版本并没有这样的问题，所以应该不是运行时的内存泄漏，而是编译时的内存泄漏，也就是内存泄漏并不是业务代码造成的，而是webpack打包配置有问题造成编译时的内存泄漏。<br>是编译时的内存泄露，那么错误报告中的堆栈信息作用就有限了，需要使用其他办法定位内存泄漏是在打包代码的什么模块时发生。<br>由于Webpack打包是静态代码打包机制，所以使用二分法来尝试webpack是在打包什么模块时产生的内存泄漏，即从入口文件开始注释掉一半的导入文件来排查内存泄漏发生在打包哪个模块的时候。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/609ad8f0e0bd1da9.png" alt="注释一半的模块重新打包来确认内存泄漏发生在哪个模块" title="注释一半的模块重新打包来确认内存泄漏发生在哪个模块"><br>从入口文件排查到打包store和router两个模块时产生了内存泄漏，而store模块内部也引入了部分router模块的内容，注释掉该部分后打包成功，说明内存泄漏发生在打包router模块时。<br>router模块引入的路由分为静态和动态两部分，同样使用二分法得到内存泄漏发生在打包路由引入的indexHome.vue和index.vue两个文件。<br>这两个文件的共同点就是都引入了这两个css文件<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/3d4804667a18189b.png" alt="可能有问题的两个css文件" title="可能有问题的两个css文件"><br>将这两个文件拿出来单独打包果然发生了内存泄漏，检查webpack打包样式文件的loader配置，发现生产版本比开发版本多一条extract的属性。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/6d65c0e19dc673d9.png" alt="config" title="config"><br>该属性配置是在生成处理样式文件的一组loader时，决定最后使用哪个loader处理之前的loader处理样式文件生成的js文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaders = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract CSS when that option is specified</span></span><br><span class="line"><span class="comment">// (which is the case during production mode)</span></span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">extract</span>)&#123;</span><br><span class="line">    loaders.<span class="title function_">push</span>(<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    loaders.<span class="title function_">push</span>(<span class="string">&#x27;vue-style-lodaer&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果extract配置为true，那么样式文件的处理最后就会使用MiniCssExxtractPlugin.loader从js文件中提取出独立的CSS文件注入。而如果配置为false,则会使用vue-style-loader直接将css样式注入。</p>
<p>这就是开发版本和生产版本处理样式文件的loader配置的不同，所以内存泄漏应该是出现在MiniCssExxtractPlugin.loader的工作流程中。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>那么解决内存泄漏最简单的解决方案当然就是不使用MiniCssExxtractPlugin.loader，这样就不会产生内存泄漏了，将extract注释掉就好。<br>但是这样打包出来的产品是没有css文件的，样式全在js文件里。本着不影响最终制品的原则，检查导致MiniCssExxtractPlugin.loader打包时内存泄漏的两个css文件。在common.css中发现以下样式配置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>: ...;</span><br><span class="line">    <span class="attribute">color</span> :...;</span><br><span class="line">    _background-attachment:fixed;</span><br><span class="line">    _background-image:<span class="built_in">url</span>(<span class="string">about:blank</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个’_’把我整懵了，搜索之后发现这是IE6才识别的写法，作用是探测应用的运行在什么浏览器上的.。(这个作用存疑，只在CSDN上看到有人说，但是WebMDN等网站并未搜索到该用法)<br>不清楚这里探测IE6浏览器的目的，能开本身也没有需要探测运行浏览器的需求，所以这两条属性直接注释掉MiniCssExxtractPlugin.loader在打包时就不会产生内存泄露了。<br><img src="https://s3.bmp.ovh/imgs/2022/04/05/609ad8f0e0bd1da9.png" alt="_的用法" title="_的用法"></p>
]]></content>
  </entry>
</search>
